Index: tests/tests.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import unittest\nimport sys\nimport os\nmyDir = os.getcwd()\nsys.path.append(myDir)\n\nfrom pathlib import Path\npath = Path(myDir)\na=str(path.parent.absolute())\n\nsys.path.append(a)\nfrom viergewinnt.main import *\n\n\nclass ViergewinntTests(unittest.TestCase):\n    def setUp(self):\n        self.Spieler1 = Spielmodus(1)\n        self.Spieler2 = Spielmodus(2)\n        self.Feld1 = Spielfeld()\n        self.gui1 = GUI()\n        self.spielregeln1 = Spielregeln()\n\n    def test_setFelder(self):\n        \"\"\"\n        Überprüft, ob Spielsteine korrekt gesetzt werden.\n        ________________________________________________\n\n        assertEqual() ist eine Unittest library Funktion, welche die gleichwertigkeit von 2 Werten überprüft.\n        Wenn beide Werte gleichwertig sind, gibt assertEqual() True zurück, andernfalls False.\n        \"\"\"\n        self.Feld1.setFelder(0)\n        erg1 = self.Feld1.getFelder()\n        self.assertEqual(erg1, [[\" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\"X\", \" \", \" \", \" \", \" \", \" \", \" \"]])\n        self.Feld1.setFelder(0)\n        erg2 = self.Feld1.getFelder()\n        self.assertEqual(erg2, [[\" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\"X\", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\"X\", \" \", \" \", \" \", \" \", \" \", \" \"]])\n        self.Feld1.setFelder(0)\n        self.Feld1.setFelder(0)\n        self.Feld1.setFelder(0)\n        erg3 = self.Feld1.getFelder()\n        self.assertEqual(erg3, [[\" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\"O\", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\"O\", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\"O\", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\"X\", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\"X\", \" \", \" \", \" \", \" \", \" \", \" \"]])\n        self.Feld1.setFelder(0)\n        erg4 = self.Feld1.getFelder()\n        self.assertEqual(erg4, [[\"O\", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\"O\", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\"O\", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\"O\", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\"X\", \" \", \" \", \" \", \" \", \" \", \" \"],\n                                [\"X\", \" \", \" \", \" \", \" \", \" \", \" \"]])\n\n\ndef test_Spielzug(self):\n    \"\"\"\n    Überprüft, ob ein Zug möglich ist.\n    _________________________________\n\n    assertTrue() ist eine weitere Unittest library Funktion, welche den test Wert mit True vergleicht.\n    Diese Funktion wird je nach Bedingung einen boolean zurückliefern. Falls der test Wert True ist,\n    dann gibt assertTrue() den Wert True zurück, andernfalls False.\n    \"\"\"\n    self.Feld1.setFelder(1)\n    # self.gui1.printSpielfeld(self.Feld1)\n    self.assertTrue(self.spielregeln1.Spielzug(self.Feld1, 1))\n    self.Feld1.setFelder(1, \"X\")\n    self.assertTrue(self.spielregeln1.Spielzug(self.Feld1, 1))\n    self.Feld1.setFelder(1, \"X\")\n    self.assertTrue(self.spielregeln1.Spielzug(self.Feld1, 1))\n    self.Feld1.setFelder(1, \"X\")\n    self.assertTrue(self.spielregeln1.Spielzug(self.Feld1, 1))\n    self.Feld1.setFelder(1, \"X\")\n    self.assertTrue(self.spielregeln1.Spielzug(self.Feld1, 1))\n    self.Feld1.setFelder(1, \"X\")\n    # self.gui1.printSpielfeld(self.Feld1)\n\n\nif __name__ == '__main__':\n    unittest.main()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/tests.py b/tests/tests.py
--- a/tests/tests.py	(revision e64d0b9b534a28ec95b845b97bb16d394b1b5bb6)
+++ b/tests/tests.py	(date 1645098755308)
@@ -42,7 +42,7 @@
                                 [" ", " ", " ", " ", " ", " ", " "],
                                 [" ", " ", " ", " ", " ", " ", " "],
                                 [" ", " ", " ", " ", " ", " ", " "],
-                                ["X", " ", " ", " ", " ", " ", " "],
+                                ["0", " ", " ", " ", " ", " ", " "],
                                 ["X", " ", " ", " ", " ", " ", " "]])
         self.Feld1.setFelder(0)
         self.Feld1.setFelder(0)
@@ -52,7 +52,7 @@
                                 ["O", " ", " ", " ", " ", " ", " "],
                                 ["O", " ", " ", " ", " ", " ", " "],
                                 ["O", " ", " ", " ", " ", " ", " "],
-                                ["X", " ", " ", " ", " ", " ", " "],
+                                ["", " ", " ", " ", " ", " ", " "],
                                 ["X", " ", " ", " ", " ", " ", " "]])
         self.Feld1.setFelder(0)
         erg4 = self.Feld1.getFelder()
@@ -73,19 +73,8 @@
     Diese Funktion wird je nach Bedingung einen boolean zurückliefern. Falls der test Wert True ist,
     dann gibt assertTrue() den Wert True zurück, andernfalls False.
     """
-    self.Feld1.setFelder(1)
-    # self.gui1.printSpielfeld(self.Feld1)
-    self.assertTrue(self.spielregeln1.Spielzug(self.Feld1, 1))
-    self.Feld1.setFelder(1, "X")
-    self.assertTrue(self.spielregeln1.Spielzug(self.Feld1, 1))
-    self.Feld1.setFelder(1, "X")
-    self.assertTrue(self.spielregeln1.Spielzug(self.Feld1, 1))
-    self.Feld1.setFelder(1, "X")
-    self.assertTrue(self.spielregeln1.Spielzug(self.Feld1, 1))
-    self.Feld1.setFelder(1, "X")
-    self.assertTrue(self.spielregeln1.Spielzug(self.Feld1, 1))
-    self.Feld1.setFelder(1, "X")
-    # self.gui1.printSpielfeld(self.Feld1)
+    self.Feld1.getFelder()
+    self.assertTrue(self.spielregeln1.Spielzug(self.gui1))
 
 
 if __name__ == '__main__':
Index: viergewinnt/main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from typing import List\nfrom random import randint\n\nZAEHLER = 0  # Diese Variable wird bei jedem Spielzug um eins erhöht.\nREIHE = 5  # Diese Variable wird dazu benötigt, dass der geworfene Spielstein immer in die tiefste Zeile fällt.\nRICHTUNGEN = [[-1, -1], [0, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]]\n# Die Richtungen dienen dazu, zu überprüfen, ob ein Spieler (in eine bestimmte Richtung) gewonnen hat.\nSPIELER = 0  # Diese Variable dient dazu, die Spieler als Spieler 1 und 2 anzusprechen.\n\n\nclass Spielfeld:\n    \"\"\"\n    Die Klasse Spielfeld umfasst alle Informationen bezüglich des Spielfeldes.\n    Das Spielfeld selbst ist ein Array aus 6 Listen bestehend aus 7 strings(Punkten).\n    \"\"\"\n\n    def __init__(self):\n        self.__felder = [[\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n                         [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n                         [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n                         [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n                         [\".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n                         [\".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\n        self.__letzteSpalte = None\n        self.__letzteReihe = None\n\n    def getFelder(self) -> List:\n        \"\"\"\n        übermittelt das Spielfeld\n        \"\"\"\n        return self.__felder\n\n    def setFelder(self, spalte: int):\n        \"\"\"\n        Setzt Spielstein in die jeweilige Spalte.\n        Ziel der Funktion ist es, dass der gespielte Stein bis zum\n        letztmöglichen Punkt fällt, und nicht z.B. in der ersten Zeile hängen bleibt.\n        ________________________________________\n\n        spalte: int\n            Gibt die Spalte die vom Spieler ausgewählt wurde, um den Stein zu setzen\n        \"\"\"\n        global REIHE, ZAEHLER\n        self.__letzteSpalte = spalte\n        geworfen = False\n        REIHE = 5\n        for liste in reversed(self.__felder):\n            if not geworfen:\n                if liste[spalte] == \".\":\n                    if (ZAEHLER % 2) == 0:\n                        liste[spalte] = 'X'\n                        ZAEHLER += 1\n                    else:\n                        liste[spalte] = '0'\n                        ZAEHLER += 1\n                    self.__letzteReihe = REIHE\n                    geworfen = True\n                elif liste[spalte] != \".\":\n                    REIHE -= 1\n                    self.__letzteReihe = REIHE\n\n    def getLetzteReihe(self) -> int:\n        \"\"\"\n        Gibt jene Reihe an, die zuletzt im Spiel bespielt wurde.\n        Die Zählung fängt bei 0 von der obersten Reihe an\n        \"\"\"\n        return self.__letzteReihe\n\n    def getLetzteSpalte(self) -> int:\n        \"\"\"\n        Gibt jene Spalte an, die zuletzt im Spiel bespielt wurde.\n        Die Zählung fängt bei 0 von links an\n        \"\"\"\n        return self.__letzteSpalte\n\n\nclass GUI:\n    \"\"\"\n    Die Klasse GUI umfasst alle Informationen bezüglich des\n    Graphical User Interfaces.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def printSpielfeld(self, feld: Spielfeld):\n        \"\"\"\n        Gibt das Spielfeld aus\n        \"\"\"\n        for liste in feld.getFelder():\n            print(liste[0], liste[1], liste[2], liste[3], liste[4], liste[5], liste[6])\n\n    def getSpielmodus(self) -> int:\n        \"\"\"\n        Die Funktion fordert vom Spieler eine Eingabe.\n        Je nach Eingabe wird ein von zwei Spielmodi ausgewählt.\n        Die Aufforderung wird so lange wiederholt, bis die Eingabe valide ist. (Parameter 1 oder 2)\n        \"\"\"\n        global SPIELER\n        gueltigeModi = [1, 2]\n        spielmodus = 0\n        SPIELER += 1\n        while spielmodus not in gueltigeModi:\n            try:\n                spielmodus = int(input(f'Spieler {SPIELER}: Bist du ein Mensch(1) oder ein Computer(2)'))\n                if spielmodus not in gueltigeModi:\n                    print(f'FALSCHE EINGABE! Bist du ein Mensch(1) oder ein Computer(2)')\n                    continue\n            except ValueError:\n                print(f'FALSCHE EINGABE! Bist du ein Mensch(1) oder ein Computer(2)')\n        return spielmodus\n\n    def beenden(self):\n        i = 0\n        while i < 1:\n            beenden = input(f'Möchtest du das Spiel aufgeben?(j/n)')\n            if beenden == \"j\":\n                return True\n            elif beenden == \"n\":\n                return False\n            else:\n                print(f'FALSCHE EINGABE! Gib \"j\"(beenden) oder \"n\"(weiterspielen) ein!')\n                continue\n\n    def erfasseSpielzug(self):\n        \"\"\"\n        Die Funktion erfasst den eingegebenen Spielzug und überprüft dabei,\n        ob es ein gültiger Spielzug ist. Falls der Spielzug nicht gültig ist,\n        wird der Spieler zu einer erneuten Eingabe aufgefordert.\n        \"\"\"\n        spalte = 0\n        gueltige_spalten = [1, 2, 3, 4, 5, 6, 7]\n\n        while spalte not in gueltige_spalten:\n            try:\n                spalte = int(input(f'In welche Spalte möchtest du werfen?'))\n                if spalte not in gueltige_spalten:\n                    print(\"FALSCHE EINGABE! Wähle eine Spalte von 1 - 7\")\n                else:\n                    return spalte - 1\n            except ValueError:\n                print(\"FALSCHE EINGABE! Wähle eine Spalte von 1 - 7\")\n\n\nclass Spielmodus:\n    \"\"\"\n    Die Klasse Spielmodus umfasst alle Informationen bezüglich dem Spielmodus\n    \"\"\"\n\n    def __init__(self, spielmodus: int):\n        \"\"\"\n        Die Funktion wählt abhängig von der Eingabe des Spielers den jeweiligen\n        Spielmodus und überprüft gleichzeitig, ob die Eingabe gültig ist. Bei einer\n        ungültigen Eingabe wird der Spieler zu einer erneuten Eingabe aufgefordert.\n        \"\"\"\n        if spielmodus == 1 or spielmodus == 2:\n            self.__spielmodus = spielmodus\n        else:\n            raise ValueError(\"Falsche Eingabe! Gib 1 ein, wenn du gegen einen Mensch spielen willst oder 2,\"\n                             \"wenn du gegen einen Computergegner spielen willst.\")\n\n    def __repr__(self):\n        return f\"Spielmodus: {self.__spielmodus}\"\n\n    @property\n    def spielmodus(self):\n        return self.__spielmodus\n\n    @spielmodus.setter\n    def spielmodus(self, value):\n        self.__spielmodus = value\n\n    def spielzug(self, gui: GUI) -> int:\n        \"\"\"\n        Die Funktion Spielzug ruft für einen menschlichen Spieler, die Methode erfasse Spielzug auf.\n        Für einen Computerspieler wird eine zufällige Spalte zwischen 0 und 6 ermittelt.\n        \"\"\"\n        if self.__spielmodus == 1:\n            spalte = gui.erfasseSpielzug()\n            return spalte\n        elif self.__spielmodus == 2:\n            spalte = randint(0, 6)\n            return spalte\n\n\nclass Spielregeln:\n    \"\"\"\n    Die Klasse Spielregeln umfasst alle Informationen bezüglich den Regeln des Spiels\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def volleSpalte(self, feld: Spielfeld, spalte: int) -> bool:\n        \"\"\"\n        Die Funktion überprüft, ob der jeweilige Spielzug des Spielers gültig ist.\n        Falls eine Spalte bereits voll ist, wird der Spieler zu einer erneuten Eingabe\n        aufgefordert.\n        \"\"\"\n        spielfeld = feld.getFelder()\n        if spielfeld[0][spalte] != \".\":\n            print(\"Spielzug nicht möglich. Spalte voll.\")\n            return False\n        else:\n            return True\n\n    def voll(self) -> bool:\n        \"\"\"\n        Diese Funktion überprüft nach jedem Spielzug, ob das Spielfeld voll ist. Der ZAEHLER wird bei jedem Spielzug,\n        um eins erhöht.\n        \"\"\"\n        if ZAEHLER < 42:\n            return False\n        else:\n            return True\n\n    def gewonnen(self, feld: Spielfeld) -> bool:\n        \"\"\"\n        Die Funktion überprüft ob einer der Spieler das Spiel gewonnen hat.\n        Die Funktion ruft das Spielfeld sowie die Zeile und Spalte des zuletzt geworfenen\n        Spielsteins ab. Die erste Schleife überprüft in alle 8 Richtungen. Zuerst wird, die Annahme getroffen, dass\n        der Spieler gewonnen hat, Die erste if-Bedingung überprüft, ob die Zeilen- bzw. Spaltenposition im\n        Spielfeld sind. Die zweite if-Bedingung überprüft, ob 4 Steine in eine bestimmte Richtung im Spielfeld sind.\n        Wenn der vierte Stein True ist, hat der Spieler gewonnen, ansonsten bricht die Schleife ab und setzt den Wert\n        von vier_in_einer-reihe auf False und das Spiel geht weiter.\n\n        \"\"\"\n        spielfeld = feld.getFelder()\n        zeile = feld.getLetzteReihe()\n        spalte = feld.getLetzteSpalte()\n        for i in range(8):\n            vier_in_einer_reihe = True\n            j = 1\n            while j < 4:\n                spaltenposition = spalte + RICHTUNGEN[i][0] * j\n                zeilenposition = zeile + RICHTUNGEN[i][1] * j\n                if zeilenposition > 5 or zeilenposition < 0 or spaltenposition > 6 or spaltenposition < 0:\n                    j += 1\n                    vier_in_einer_reihe = False\n                    break\n                if spielfeld[zeile][spalte] == spielfeld[zeilenposition][spaltenposition]:\n                    j += 1\n                    continue\n                vier_in_einer_reihe = False\n                break\n            if vier_in_einer_reihe:\n                return True\n\n\nclass DasSpiel:\n    \"\"\"\n    Erstellt das Spiel.\n    In der init Funktion wird das Spielfeld, das GUI, die Spielregeln sowie die Spielmodi\n    initialisiert. Zuerst wird abgefragt, ob die Spieler Mensch oder Computer sind. In der spielStart-Funktion wird\n    überprüft, ob das Spielfeld voll ist. Wenn das Spielfeld voll ist, wird Unentschieden ausgegeben. Nach jedem Zug\n    wird ein menschlicher Spieler gefragt, ob er/sie aufgeben will(beenden). Nach jedem geworfenen Stein, wird überprüft,\n    ob der Spieler gewonnen hat und das aktuelle Spielfeld wird ausgegeben.\n    \"\"\"\n\n    def __init__(self):\n        self.__feld = Spielfeld()\n        self.__gui = GUI()\n        self.__spielregeln = Spielregeln()\n        self.spieler1 = Spielmodus(2)\n        self.spieler2 = Spielmodus(2)\n\n    def spielStart(self):\n        spielmodus_spieler1 = self.__gui.getSpielmodus()\n        self.spieler1.spielmodus = spielmodus_spieler1\n        spielmodus_spieler2 = self.__gui.getSpielmodus()\n        self.spieler2.spielmodus = spielmodus_spieler2\n        self.__gui.printSpielfeld(self.__feld)\n        while True:\n            ueberpruefe_spielzug_spieler1 = False\n            spielzug_spieler_1 = None\n            if spielmodus_spieler1 == 1:\n                beenden = self.__gui.beenden()\n                if beenden:\n                    print(\"Spieler 2 hat gewonnen!\")\n                    break\n            while not ueberpruefe_spielzug_spieler1:\n                spielzug_spieler_1 = self.spieler1.spielzug(self.__gui)\n                ueberpruefe_spielzug_spieler1 = self.__spielregeln.volleSpalte(self.__feld, spielzug_spieler_1)\n\n            self.__feld.setFelder(spielzug_spieler_1)\n            self.__gui.printSpielfeld(self.__feld)\n            if self.__spielregeln.voll():\n                print(\"Das Spielfeld ist voll. UNENTSCHIEDEN!\")\n                break\n            if self.__spielregeln.gewonnen(self.__feld):\n                print(\"Spieler 1 hat gewonnen!\")\n                break\n\n            ueberpruefe_spielzug_spieler2 = False\n            spielzug_spieler_2 = None\n            if spielmodus_spieler2 == 1:\n                beenden = self.__gui.beenden()\n                if beenden:\n                    print(\"Spieler 1 hat gewonnen!\")\n                    break\n            while not ueberpruefe_spielzug_spieler2:\n                spielzug_spieler_2 = self.spieler2.spielzug(self.__gui)\n                ueberpruefe_spielzug_spieler2 = self.__spielregeln.volleSpalte(self.__feld, spielzug_spieler_2)\n\n            self.__feld.setFelder(spielzug_spieler_2)\n            self.__gui.printSpielfeld(self.__feld)\n            if self.__spielregeln.voll():\n                print(\"Das Spielfeld ist voll. UNENTSCHIEDEN!\")\n                break\n            if self.__spielregeln.gewonnen(self.__feld):\n                print(\"Spieler 2 hat gewonnen!\")\n                break\n\n\nif __name__ == '__main__':\n    game = DasSpiel()\n    game.spielStart()\n\n\"\"\"\nclass Ki:\n    def __init__(self):\n        pass\n\n    def quadsErmitteln(self):\n        zaehler = 0\n        quads = {}\n        bekannte_positionen = set()\n        for i in range(42):\n            for richtung in RICHTUNGEN:\n                position = (i % 7, i // 7)\n                positionen = quadPositionen(position, richtung)\n                if not positionen or positionen in bekannte_positionen:\n                    continue\n                quads[zaehler] = [0, 0]  # Anzahl der gelben[0], roten[1] Steine im Quad\n                for position in positionen:\n                    pos2Index[position].append([zaehler])\n                bekannte_positionen.add(frozenset(positionen))\n                # frozenset bewirkt, dass man einem set ein anderes set hinzufügen kann.\n                zaehler += 1\n        return quads\n\n    def quadPositionen(self, position, richtung):\n        positionen = set()\n        spalte, zeile = position\n        spaltenrichtung, zeilenrichtung = richtung\n        neue_spalte, neue_zeile = spalte + spaltenrichtung * 3, zeile + zeilenrichtung * 3\n        if neue_spalte < 0 or neue_spalte >= SPALTEN or neue_zeile < 0 or neue_zeile >= ZEILEN:\n            return False\n        for i in range(4):\n            positionen.add((spalte + spaltenrichtung * i, zeile + zeilenrichtung * i))\n        return positionen\n\n    def steinLoeschen(self, position, spieler):\n        del spielfeld[position]\n        for i in pos2Index[position]:\n            quads[i][spieler] -= 1\n\n    def bewerten(self):\n        score = 0\n        for position in spielfeld:\n            for i in pos2Index[position]:\n                gelbe, rote = quads[i]\n                if gelbe > 0 and rote > 0:\n                    continue\n                score += rote * 10\n                score -= gelbe * 10\n        return score\n\n    def computer(self, spieler):\n        bewertete_zuege = []\n        for zug in zugliste():\n            sieg = steinSetzen(zug, spieler)\n            score = minimax(7, -999999, 999999, spieler, sieg)\n            steinLoeschen(zug, spieler)\n            bewertete_zuege.append((score, zug))\n        bewertete_zuege.sort(reverse=spieler)\n        score, bester_zug = bewertete_zuege[0]\n        sieg = steinSetzen(bester_zug, spieler)\n        print(f'Spieler {1 if spieler else 2} setzt {bester_zug} mit der Bewertung {score}')\n        return sieg\n\n    def minimax(self, tiefe, alpha, beta, spieler, sieg):\n        if sieg:\n            return 99999 + tiefe if spieler else -99999 - tiefe\n        if tiefe == 0 or len(spielfeld) == ZELLEN:\n            return bewerten()\n        spieler = not spieler\n        value = -999999 if spieler else 999999\n        for zug in zugliste():\n            sieg = steinSetzen(zug, spieler)\n            score = minimax(tiefe - 1, alpha, beta, spieler, sieg)\n            steinLoeschen(zug, spieler)\n            if spieler:\n                value = max(value, score)\n                alpha = max(value, alpha)\n            else:\n                value = min(value, score)\n                beta = min(value, beta)\n            if alpha >= beta:\n                break\n        return value\n\n\"\"\"\n\n\"\"\"\nDie KI hat die folgende Funktionsweise:\nZuerst werden alle gültigen Quads gefunden. D.h. Es werden von allen Positionen(ZELLEN), in alle Richtungen\nüberprüft, ob es ein mögliches Quad gibt, um zu gewinnen.\n\n# Diese Funktion liefert alle möglichen Züge\ndef zugliste():\n    zuege = []\n    for spalte in range(SPALTEN):\n        if not spalteGueltig(spalte):\n            continue\n        zeile = findeTiefsteZeile(spalte)\n        zuege.append((spalte, zeile))\n    return zuege\n\n\nspieler = True\nquads = quadsErmitteln()\nwhile True:\n    printSpielfeld()\n    if spieler:\n        sieg = human(spieler)\n    else:\n        sieg = human(spieler)\n    if sieg:\n        printSpielfeld()\n        print('GEWONNEN!!!')\n        break\n    spieler = not spieler\n\n'''\n    Der Ablauf des Spiels schaut folgendermaßen aus:\n    Zuerst wird das leere Spielfeld ausgegeben.\n    Danach wählt der/die erste SpielerIn eine Spalte aus in die er/sie den Stein werfen will.\n    Es wird überprüft, ob die Eingabe der Spalte gültig ist. (Werte von 0-6 sind erlaubt.)\n    Danach wird überprüft ob, der/die SpielerIn gewonnen hat. (4 Steine in eine bestimmte Richtung.)\n    Falls, dass nicht der Fall ist wirft der nächste Spieler einen Stein.\n    Es wird wieder die Gültigkeit der Spalte und ob gewonnen wurde überprüft.\n    Dies wird solange durchgeführt, bis ein Spieler gewonnen hat oder das Spielfeld voll mit Steinen ist.\n    '''\n\"\"\"\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/viergewinnt/main.py b/viergewinnt/main.py
--- a/viergewinnt/main.py	(revision e64d0b9b534a28ec95b845b97bb16d394b1b5bb6)
+++ b/viergewinnt/main.py	(date 1645098127555)
@@ -315,131 +315,3 @@
 if __name__ == '__main__':
     game = DasSpiel()
     game.spielStart()
-
-"""
-class Ki:
-    def __init__(self):
-        pass
-
-    def quadsErmitteln(self):
-        zaehler = 0
-        quads = {}
-        bekannte_positionen = set()
-        for i in range(42):
-            for richtung in RICHTUNGEN:
-                position = (i % 7, i // 7)
-                positionen = quadPositionen(position, richtung)
-                if not positionen or positionen in bekannte_positionen:
-                    continue
-                quads[zaehler] = [0, 0]  # Anzahl der gelben[0], roten[1] Steine im Quad
-                for position in positionen:
-                    pos2Index[position].append([zaehler])
-                bekannte_positionen.add(frozenset(positionen))
-                # frozenset bewirkt, dass man einem set ein anderes set hinzufügen kann.
-                zaehler += 1
-        return quads
-
-    def quadPositionen(self, position, richtung):
-        positionen = set()
-        spalte, zeile = position
-        spaltenrichtung, zeilenrichtung = richtung
-        neue_spalte, neue_zeile = spalte + spaltenrichtung * 3, zeile + zeilenrichtung * 3
-        if neue_spalte < 0 or neue_spalte >= SPALTEN or neue_zeile < 0 or neue_zeile >= ZEILEN:
-            return False
-        for i in range(4):
-            positionen.add((spalte + spaltenrichtung * i, zeile + zeilenrichtung * i))
-        return positionen
-
-    def steinLoeschen(self, position, spieler):
-        del spielfeld[position]
-        for i in pos2Index[position]:
-            quads[i][spieler] -= 1
-
-    def bewerten(self):
-        score = 0
-        for position in spielfeld:
-            for i in pos2Index[position]:
-                gelbe, rote = quads[i]
-                if gelbe > 0 and rote > 0:
-                    continue
-                score += rote * 10
-                score -= gelbe * 10
-        return score
-
-    def computer(self, spieler):
-        bewertete_zuege = []
-        for zug in zugliste():
-            sieg = steinSetzen(zug, spieler)
-            score = minimax(7, -999999, 999999, spieler, sieg)
-            steinLoeschen(zug, spieler)
-            bewertete_zuege.append((score, zug))
-        bewertete_zuege.sort(reverse=spieler)
-        score, bester_zug = bewertete_zuege[0]
-        sieg = steinSetzen(bester_zug, spieler)
-        print(f'Spieler {1 if spieler else 2} setzt {bester_zug} mit der Bewertung {score}')
-        return sieg
-
-    def minimax(self, tiefe, alpha, beta, spieler, sieg):
-        if sieg:
-            return 99999 + tiefe if spieler else -99999 - tiefe
-        if tiefe == 0 or len(spielfeld) == ZELLEN:
-            return bewerten()
-        spieler = not spieler
-        value = -999999 if spieler else 999999
-        for zug in zugliste():
-            sieg = steinSetzen(zug, spieler)
-            score = minimax(tiefe - 1, alpha, beta, spieler, sieg)
-            steinLoeschen(zug, spieler)
-            if spieler:
-                value = max(value, score)
-                alpha = max(value, alpha)
-            else:
-                value = min(value, score)
-                beta = min(value, beta)
-            if alpha >= beta:
-                break
-        return value
-
-"""
-
-"""
-Die KI hat die folgende Funktionsweise:
-Zuerst werden alle gültigen Quads gefunden. D.h. Es werden von allen Positionen(ZELLEN), in alle Richtungen
-überprüft, ob es ein mögliches Quad gibt, um zu gewinnen.
-
-# Diese Funktion liefert alle möglichen Züge
-def zugliste():
-    zuege = []
-    for spalte in range(SPALTEN):
-        if not spalteGueltig(spalte):
-            continue
-        zeile = findeTiefsteZeile(spalte)
-        zuege.append((spalte, zeile))
-    return zuege
-
-
-spieler = True
-quads = quadsErmitteln()
-while True:
-    printSpielfeld()
-    if spieler:
-        sieg = human(spieler)
-    else:
-        sieg = human(spieler)
-    if sieg:
-        printSpielfeld()
-        print('GEWONNEN!!!')
-        break
-    spieler = not spieler
-
-'''
-    Der Ablauf des Spiels schaut folgendermaßen aus:
-    Zuerst wird das leere Spielfeld ausgegeben.
-    Danach wählt der/die erste SpielerIn eine Spalte aus in die er/sie den Stein werfen will.
-    Es wird überprüft, ob die Eingabe der Spalte gültig ist. (Werte von 0-6 sind erlaubt.)
-    Danach wird überprüft ob, der/die SpielerIn gewonnen hat. (4 Steine in eine bestimmte Richtung.)
-    Falls, dass nicht der Fall ist wirft der nächste Spieler einen Stein.
-    Es wird wieder die Gültigkeit der Spalte und ob gewonnen wurde überprüft.
-    Dies wird solange durchgeführt, bis ein Spieler gewonnen hat oder das Spielfeld voll mit Steinen ist.
-    '''
-"""
Index: 4gewinnt.egg-info/SOURCES.txt
===================================================================
diff --git a/4gewinnt.egg-info/SOURCES.txt b/4gewinnt.egg-info/SOURCES.txt
deleted file mode 100644
--- a/4gewinnt.egg-info/SOURCES.txt	(revision e64d0b9b534a28ec95b845b97bb16d394b1b5bb6)
+++ /dev/null	(revision e64d0b9b534a28ec95b845b97bb16d394b1b5bb6)
@@ -1,8 +0,0 @@
-README.md
-setup.py
-4gewinnt.egg-info/PKG-INFO
-4gewinnt.egg-info/SOURCES.txt
-4gewinnt.egg-info/dependency_links.txt
-4gewinnt.egg-info/top_level.txt
-viergewinnt/__init__.py
-viergewinnt/main.py
\ No newline at end of file
Index: 4gewinnt.egg-info/dependency_links.txt
===================================================================
diff --git a/4gewinnt.egg-info/dependency_links.txt b/4gewinnt.egg-info/dependency_links.txt
deleted file mode 100644
--- a/4gewinnt.egg-info/dependency_links.txt	(revision e64d0b9b534a28ec95b845b97bb16d394b1b5bb6)
+++ /dev/null	(revision e64d0b9b534a28ec95b845b97bb16d394b1b5bb6)
@@ -1,1 +0,0 @@
-
Index: 4gewinnt.egg-info/top_level.txt
===================================================================
diff --git a/4gewinnt.egg-info/top_level.txt b/4gewinnt.egg-info/top_level.txt
deleted file mode 100644
--- a/4gewinnt.egg-info/top_level.txt	(revision e64d0b9b534a28ec95b845b97bb16d394b1b5bb6)
+++ /dev/null	(revision e64d0b9b534a28ec95b845b97bb16d394b1b5bb6)
@@ -1,1 +0,0 @@
-viergewinnt
